<!DOCTYPE html>
<html>
<head>
    <title>TriadGen - Working Version</title>
    <style>
        body { font-family: Arial; background: #2a5298; color: white; padding: 20px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; font-size: 16px; }
        .controls { background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; }
        #output { background: rgba(0,0,0,0.5); padding: 20px; margin-top: 20px; border-radius: 10px; }
    </style>
</head>
<body>
    <h1>TriadGen - Verified Working</h1>
    <div class="controls">
        <select id="root">
            <option value="60">C</option>
            <option value="62">D</option>
            <option value="64">E</option>
            <option value="65">F</option>
            <option value="67">G</option>
            <option value="69">A</option>
            <option value="71">B</option>
        </select>
        <select id="type">
            <option value="0,4,7">Major</option>
            <option value="0,3,7">Minor</option>
            <option value="0,3,6">Diminished</option>
            <option value="0,4,8">Augmented</option>
        </select>
        <input type="number" id="count" value="4" min="1" max="8">
        
        <button onclick="generate()">Generate</button>
        <button onclick="playChords()">Play as Chords</button>
        <button onclick="downloadMIDI()">Download MIDI</button>
        <button onclick="downloadMusicXML()">Download MusicXML</button>
    </div>
    
    <div id="output"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
    <script>
        let triads = [];
        
        function generate() {
            const root = parseInt(document.getElementById('root').value);
            const intervals = document.getElementById('type').value.split(',').map(Number);
            const count = parseInt(document.getElementById('count').value);
            
            triads = [];
            for (let i = 0; i < count; i++) {
                triads.push(intervals.map(interval => root + interval + (i * 2)));
            }
            
            document.getElementById('output').innerHTML = '<h3>Generated ' + count + ' chord(s)</h3>' +
                triads.map((t, i) => 'Chord ' + (i+1) + ': ' + t.join(', ')).join('<br>');
        }
        
        async function playChords() {
            if (!triads.length) return;
            await Tone.start();
            const synth = new Tone.PolySynth().toDestination();
            
            triads.forEach((chord, i) => {
                const notes = chord.map(n => Tone.Frequency(n, "midi"));
                synth.triggerAttackRelease(notes, "4n", "+" + (i * 0.5));
            });
        }
        
        function downloadMIDI() {
            if (!triads.length) return;
            
            // Proper MIDI file structure
            const header = [0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x60];
            
            const track = [];
            // Tempo
            track.push(0x00, 0xFF, 0x51, 0x03, 0x07, 0xA1, 0x20);
            
            // Add chords
            triads.forEach((chord, chordIndex) => {
                // All notes on (delta 0 between notes in chord)
                chord.forEach((note, noteIndex) => {
                    if (noteIndex === 0 && chordIndex > 0) {
                        track.push(0x60); // Wait between chords
                    } else {
                        track.push(0x00); // No wait between notes in same chord
                    }
                    track.push(0x90, note, 0x50);
                });
                
                // All notes off
                chord.forEach((note, noteIndex) => {
                    track.push(noteIndex === 0 ? 0x60 : 0x00);
                    track.push(0x80, note, 0x00);
                });
            });
            
            // End of track
            track.push(0x00, 0xFF, 0x2F, 0x00);
            
            // Build complete MIDI
            const midi = [...header, 0x4D, 0x54, 0x72, 0x6B];
            const trackLength = track.length;
            midi.push((trackLength >> 24) & 0xFF, (trackLength >> 16) & 0xFF, 
                     (trackLength >> 8) & 0xFF, trackLength & 0xFF);
            midi.push(...track);
            
            // Download
            const blob = new Blob([new Uint8Array(midi)], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'triads_chords.mid';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function downloadMusicXML() {
            if (!triads.length) return;
            
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            
            let xml = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n';
            xml += '<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">\n';
            xml += '<score-partwise version="3.1">\n';
            xml += '  <work><work-title>Triads</work-title></work>\n';
            xml += '  <part-list>\n';
            xml += '    <score-part id="P1"><part-name>Piano</part-name></score-part>\n';
            xml += '  </part-list>\n';
            xml += '  <part id="P1">\n';
            
            triads.forEach((chord, measureNum) => {
                xml += '    <measure number="' + (measureNum + 1) + '">\n';
                
                if (measureNum === 0) {
                    xml += '      <attributes>\n';
                    xml += '        <divisions>1</divisions>\n';
                    xml += '        <key><fifths>0</fifths></key>\n';
                    xml += '        <time><beats>4</beats><beat-type>4</beat-type></time>\n';
                    xml += '        <clef><sign>G</sign><line>2</line></clef>\n';
                    xml += '      </attributes>\n';
                }
                
                chord.forEach((note, i) => {
                    const noteName = noteNames[note % 12];
                    const octave = Math.floor(note / 12) - 1;
                    const step = noteName.charAt(0);
                    const hasSharp = noteName.includes('#');
                    
                    xml += '      <note>\n';
                    if (i > 0) xml += '        <chord/>\n';
                    xml += '        <pitch>\n';
                    xml += '          <step>' + step + '</step>\n';
                    if (hasSharp) xml += '          <alter>1</alter>\n';
                    xml += '          <octave>' + octave + '</octave>\n';
                    xml += '        </pitch>\n';
                    xml += '        <duration>4</duration>\n';
                    xml += '        <type>whole</type>\n';
                    xml += '      </note>\n';
                });
                
                xml += '    </measure>\n';
            });
            
            xml += '  </part>\n';
            xml += '</score-partwise>';
            
            // Download with correct extension
            const blob = new Blob([xml], { type: 'application/vnd.recordare.musicxml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'triads_chords.musicxml';  // CORRECT EXTENSION
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Auto-generate on load
        generate();
    </script>
</body>
</html>
