<!DOCTYPE html>
<html>
<head>
    <title>TriadGen - BULLETPROOF Edition</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .controls {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 5px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        .status {
            background: rgba(0,0,0,0.5);
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            text-align: center;
        }
        #output {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            min-height: 200px;
        }
        .triad {
            display: inline-block;
            margin: 10px;
            padding: 15px;
            background: rgba(255,255,255,0.2);
            border-radius: 8px;
        }
        select, input {
            padding: 8px;
            margin: 5px;
            border-radius: 5px;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéπ TriadGen - BULLETPROOF Edition</h1>
        <div class="status" id="status">‚úÖ All Systems Ready</div>
        
        <div class="controls">
            <div>
                <label>Root Note:
                    <select id="root">
                        <option value="60">C</option>
                        <option value="62">D</option>
                        <option value="64">E</option>
                        <option value="65">F</option>
                        <option value="67">G</option>
                        <option value="69">A</option>
                        <option value="71">B</option>
                    </select>
                </label>
                
                <label>Type:
                    <select id="triadType">
                        <option value="major">Major</option>
                        <option value="minor">Minor</option>
                        <option value="diminished">Diminished</option>
                        <option value="augmented">Augmented</option>
                    </select>
                </label>
                
                <label>Count:
                    <input type="number" id="count" value="4" min="1" max="16">
                </label>
            </div>
            
            <div style="margin-top: 20px;">
                <button onclick="generateTriads()" style="background: #2196F3;">üé≤ Generate Triads</button>
                <button onclick="playTriads()" style="background: #4CAF50;">‚ñ∂Ô∏è Play</button>
                <button onclick="stopPlayback()" style="background: #f44336;">‚èπ Stop</button>
                <button onclick="exportMIDI()" style="background: #FF9800;">üíæ Export MIDI</button>
                <button onclick="testEverything()" style="background: #9C27B0;">üß™ Test All</button>
            </div>
        </div>
        
        <div id="output"></div>
    </div>

    <!-- Load Tone.js -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
    
    <script>
        // Global variables
        let currentTriads = [];
        let synth = null;
        let isPlaying = false;
        
        // Status update
        function updateStatus(message, color = '#4CAF50') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.background = color;
        }
        
        // BULLETPROOF Triad Generation
        function generateTriads() {
            updateStatus('üé≤ Generating triads...');
            
            const root = parseInt(document.getElementById('root').value);
            const type = document.getElementById('triadType').value;
            const count = parseInt(document.getElementById('count').value);
            
            currentTriads = [];
            
            const intervals = {
                major: [0, 4, 7],
                minor: [0, 3, 7],
                diminished: [0, 3, 6],
                augmented: [0, 4, 8]
            };
            
            for (let i = 0; i < count; i++) {
                const triad = {
                    root: root + (i * 2), // Move up by steps
                    type: type,
                    notes: intervals[type].map(interval => root + interval + (i * 2))
                };
                currentTriads.push(triad);
            }
            
            displayTriads();
            updateStatus('‚úÖ Generated ' + count + ' triads');
            
            // Save to memory
            if (window.RCM) {
                window.RCM.save({ triads: currentTriads }, 'TriadGen');
            }
            
            return currentTriads;
        }
        
        // Display triads
        function displayTriads() {
            const output = document.getElementById('output');
            let html = '<h3>Generated Triads:</h3>';
            
            currentTriads.forEach((triad, index) => {
                html += '<div class="triad">';
                html += '<strong>Triad ' + (index + 1) + '</strong><br>';
                html += 'Type: ' + triad.type + '<br>';
                html += 'Notes: ' + triad.notes.map(n => noteToName(n)).join(', ');
                html += '</div>';
            });
            
            output.innerHTML = html;
        }
        
        // Convert MIDI to note name
        function noteToName(midi) {
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(midi / 12) - 1;
            return notes[midi % 12] + octave;
        }
        
        // BULLETPROOF Play Function
        async function playTriads() {
            if (currentTriads.length === 0) {
                updateStatus('‚ö†Ô∏è Generate triads first!', '#FF9800');
                return;
            }
            
            updateStatus('üîä Playing...', '#2196F3');
            isPlaying = true;
            
            // Initialize Tone.js
            await Tone.start();
            
            // Create or reinitialize synth
            if (synth) synth.dispose();
            synth = new Tone.PolySynth(Tone.Synth, {
                envelope: {
                    attack: 0.02,
                    decay: 0.1,
                    sustain: 0.3,
                    release: 1
                }
            }).toDestination();
            
            // Schedule playback
            let time = Tone.now();
            
            currentTriads.forEach((triad, index) => {
                // Play each triad as a chord
                synth.triggerAttackRelease(
                    triad.notes.map(n => Tone.Frequency(n, "midi")),
                    "2n",
                    time + (index * 0.5)
                );
            });
            
            // Stop status after playback
            setTimeout(() => {
                if (isPlaying) {
                    updateStatus('‚úÖ Playback complete');
                    isPlaying = false;
                }
            }, currentTriads.length * 500);
        }
        
        // Stop playback
        function stopPlayback() {
            if (synth) {
                synth.releaseAll();
                Tone.Transport.stop();
            }
            isPlaying = false;
            updateStatus('‚èπ Stopped');
        }
        
        // BULLETPROOF MIDI Export
        function exportMIDI() {
            if (currentTriads.length === 0) {
                updateStatus('‚ö†Ô∏è Generate triads first!', '#FF9800');
                return;
            }
            
            updateStatus('üíæ Exporting MIDI...');
            
            // Create MIDI file
            const midi = new MIDIFile();
            
            // Add tempo
            midi.setTempo(120);
            
            // Add notes
            let time = 0;
            currentTriads.forEach(triad => {
                triad.notes.forEach(note => {
                    midi.addNote(0, note, 80, time, 480); // channel, pitch, velocity, time, duration
                });
                time += 480; // Move forward one beat
            });
            
            // Download
            const blob = new Blob([midi.getBytes()], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'triads.mid';
            a.click();
            
            updateStatus('‚úÖ MIDI exported');
        }
        
        // Simple MIDI File creator (embedded)
        class MIDIFile {
            constructor() {
                this.tracks = [[]];
                this.ticksPerQuarter = 480;
            }
            
            setTempo(bpm) {
                const tempo = Math.floor(60000000 / bpm);
                this.tracks[0].push({
                    deltaTime: 0,
                    type: 0xFF,
                    subtype: 0x51,
                    data: [(tempo >> 16) & 0xFF, (tempo >> 8) & 0xFF, tempo & 0xFF]
                });
            }
            
            addNote(channel, pitch, velocity, time, duration) {
                // Note ON
                this.tracks[0].push({
                    deltaTime: time,
                    type: 0x90 | channel,
                    data: [pitch, velocity]
                });
                
                // Note OFF
                this.tracks[0].push({
                    deltaTime: duration,
                    type: 0x80 | channel,
                    data: [pitch, 0]
                });
            }
            
            getBytes() {
                const bytes = [];
                
                // Header
                bytes.push(...[0x4D, 0x54, 0x68, 0x64]); // "MThd"
                bytes.push(...[0x00, 0x00, 0x00, 0x06]); // Header size
                bytes.push(...[0x00, 0x00]); // Format 0
                bytes.push(...[0x00, 0x01]); // 1 track
                bytes.push(...[0x01, 0xE0]); // 480 ticks per quarter
                
                // Track
                const trackBytes = [];
                this.tracks[0].forEach(event => {
                    // Delta time
                    trackBytes.push(...this.encodeVarLength(event.deltaTime || 0));
                    
                    if (event.type === 0xFF) {
                        // Meta event
                        trackBytes.push(0xFF, event.subtype, event.data.length, ...event.data);
                    } else {
                        // MIDI event
                        trackBytes.push(event.type, ...event.data);
                    }
                });
                
                // End of track
                trackBytes.push(0x00, 0xFF, 0x2F, 0x00);
                
                // Track header
                bytes.push(...[0x4D, 0x54, 0x72, 0x6B]); // "MTrk"
                const len = trackBytes.length;
                bytes.push((len >> 24) & 0xFF, (len >> 16) & 0xFF, (len >> 8) & 0xFF, len & 0xFF);
                bytes.push(...trackBytes);
                
                return new Uint8Array(bytes);
            }
            
            encodeVarLength(value) {
                const bytes = [];
                do {
                    let byte = value & 0x7F;
                    value >>= 7;
                    if (bytes.length > 0) byte |= 0x80;
                    bytes.unshift(byte);
                } while (value > 0);
                return bytes.length ? bytes : [0];
            }
        }
        
        // Test everything
        function testEverything() {
            updateStatus('üß™ Testing all functions...');
            
            // Test 1: Generate
            generateTriads();
            setTimeout(() => {
                // Test 2: Play
                playTriads();
                setTimeout(() => {
                    // Test 3: Stop
                    stopPlayback();
                    setTimeout(() => {
                        // Test 4: Export
                        exportMIDI();
                        updateStatus('‚úÖ All tests complete!', '#4CAF50');
                    }, 1000);
                }, 2000);
            }, 500);
        }
        
        // Initialize on load
        window.onload = () => {
            updateStatus('‚úÖ BULLETPROOF TriadGen Ready!');
            
            // Auto-generate on load
            generateTriads();
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === ' ') { e.preventDefault(); playTriads(); }
                if (e.key === 'g') generateTriads();
                if (e.key === 's') stopPlayback();
                if (e.key === 'e') exportMIDI();
            });
        };
    </script>
</body>
</html>
<script src="fix_chord_playback.js"></script>
